<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>

<script>


function getData (dataId, getNextData){
    setTimeout(() => {
        console.log(dataId);
        if(getNextData){
            getNextData();
        }
    }, 2000);
}

// This method is called callback 
// This type of method creates callback hell [difficult to understand and manage] problem as follows.
getData(12, () => {
    console.log('Data two is loading....');
    getData(22, () => {
        console.log('Data three is loading....');
        getData(100, () => {
            console.log('Data four is loading....');
            getData(3232);
        });
    });
});


// Promise (We can use it as a solution to callback hell problem)
// The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.


// Method - 1
// Creation of a promise
const promisesOne = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log('Loading is complete!');
        resolve(); // We have to call this resolve() to connect with .then() 
    } ,1000);
});
// Comsumption of promise
promisesOne.then(() => {
    console.log('Promise consumed');
});
/* [Output] => 
    Loading is complete!
    Promise consumed
*/


// Method - 2 (Creation and cunsumption in one part)
new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log('Second loadiong is complete');
        resolve();
    },1000)
}).then(() => {
    console.log('Second promise consumed');
});
/* [Output] => 
    Second loading is complete
    Second promise consumed
*/

// Method - 3 (How data pass through the resolve() ?)
new Promise((resolve, reject) => {
    setTimeout(()=> {
        resolve({username: "Abhilash", password:"abhilash@1234"});
    },1000)
}).then((res) => {
        console.log(res.password);
});


// Method - 4 (Promise Channing)
function asyncFunc1() {
    return new Promise((resolve, reject) =>{
        setTimeout(() => {
            console.log("1st data");
            resolve();
        },4000)
    })
}

function asyncFunc2() {
    return new Promise((resolve, reject) =>{
        setTimeout(() => {
            console.log("2nd data");
            resolve();
        },4000)
    })
}

console.log("Fetching 1st data....");
asyncFunc1().then((res) => {
    console.log("Fetching 2nd data.....");
    asyncFunc2().then((res) => {});
});


 // Method - 5 (Handeling the reject)
 new Promise((resolve, reject) => {
    setTimeout(() => {
        let error = true; // We have a error here
        if (error == false){
            resolve({username: "Abhinandan", password:"5343434@1223ert"});
        } else {
            reject('ERROR : Something went wrong!');
        }
    },1000);
 }).then((user) => {
    console.log(user);
    return user.username;
 }).then((username) => {
    console.log(username);
 }).catch((err) => {
    console.log(err)
 }).finally(() => console.log('Experiment completed')) ;
 //The finally() method of Promise instances schedules a function to be called when the promise is settled (either fulfilled or rejected).



 // async-await [Example - 1]
 function getInformation(info){
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log('Username:',info);
            resolve();
        },2000)
    })
 }

 async function getAllData(info){
    console.log('Please wait for a while')
    await getInformation("Abhil@sh_Abhin@na@n");
    console.log('Please wait for a while')
    await getInformation("The real coder");
 }
 getAllData();



// async-await [Example - 2]
 function resolveAfter2Seconds() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve('resolved');
    }, 2000);
  });
}

async function asyncCall() {
  console.log('calling');
  const result = await resolveAfter2Seconds();
  console.log(result);
  // Expected output: "resolved"
}
asyncCall();



// But async-await can not handel errors directly
// To handel errors we have to use try catch method
const promiseFive = new Promise((resolve, reject) => {
    setTimeout(() => {
        let error = true; // We have a error here
        if (error == false){
            resolve({username: "xysdert", password:"5343434@1223ert"});
        } else {
            reject('ERROR : Something went wrong!');
        }
    },1000);
 });

 async function consumePromiseFive(){
    try {
        const response = await promiseFive;
    console.log(response);
 
    } catch (error) {
        console.log(error);
    }
 }
 consumePromiseFive();


 async function getAllUsers(){
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users')

        const data = await response.json()
        console.log(data);
    } catch (error) {
        console.log("E: ", error);
    }
}

getAllUsers()

// fetch()
// The global fetch() method starts the process of fetching a resource from the network.
// It returns => promises.

// Interview perspective => [IMP] ************************
// A fetch() promise only rejects when the request fails, for example, because of a badly-formed request URL or a network error.
// A fetch() promise does not reject if the server responds with HTTP status codes that indicate errors (404, 504, etc.).

fetch('https://api.github.com/users/hiteshchoudhary')
.then((response) => {
    return response.json()
})
.then((data) => {
    console.log(data);
})
.catch((error) => console.log(error))
 </script>
</html>